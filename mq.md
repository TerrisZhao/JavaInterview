# mq

### 如何保证数据不丢失

```
根据不同的mq处理方式可能不同，但是总体思路是一样的。
1、生产阶段
生产者（Producer） 通过网络发送消息给 Broker，当 Broker 收到之后，将会返回确认响应信息给 Producer。所以生产者只要接收到返回的确认响应，就代表消息在生产阶段未丢失。
这就就变成同步操作，但是要有性能考虑，常见的mq都会提供回调方法。


kafka + rocketmq todo 补充 几个核心参数


2、存储阶段
要了解用到的mq得集群方案，mq节点收到消息后，同步到从节点失败或刷盘失败都会导致丢失。不同mq的实现有差异。


3、消费阶段
消费业务执行成功后才给ack，同时要做好幂等。
kakfa offset 需要设置为手动提交


如果依赖mq保证消息不丢必然会丢失一部分性能，可以考虑业务上实现重试等方式。

```



### 如何保证消息顺序

```
根据不同的mq处理方式可能不同，但是总体思路是一样的。
1、写入阶段
消息要按顺序写入同一个分区，


2、存储阶段
mq本身要有offset的概念，提供顺序消费的功能。


3、消费阶段
消费阶段要保证按顺序消费，如果使用多线程消费，需要在关键点加锁或是单线程消费。


顺序消费伴随的吞吐量降低，要考虑能不能把全局顺序消费改成分区顺序消费，或业务实现。

```



### 如何保证消息不被重复消费

```
保证消息消费时的幂等性
幂等方式比较多，
业务id检测，
唯一索引验证， 创建订单，不用redis的场景，看候选人是否能想到唯一索引


问：如何设计一个接口幂等通用功能  
如果候选人想到 通过参数比较， 可以问候选人，把所有参数都作为redis的key 会不会比较大
数据签名验证等 ， 场景咱们内部的防重接口 考察点 数据签名，参数顺序
```



### 如何处理消息积压

```
场景：
设计系统时，要保证消费端的消费性能要高于生产者的发送性能，这样系统才能健康持续运行。
消息积压产生的原因有2种：第一是消息生产速度过快，另一种是消息消费速度变慢。可以通过查看消息队列内置的监控数据，确定是生产端还是消费端的原因。


如果是消费端的原因，就进行消费端性能优化：


首先可以优化消费业务逻辑，尽量减少冗余。还可以增加消费端的并发数，也就是扩容Consumer实例，也必须同步扩容主题中的队列数量，确保Consumer的实例数量和队列数量相等。


问：如果Consumer的实例数量和队列数量相等，消息积压数量还是比较大，如何处理
答：可以将消息转发到其他的topic处理，如果消息实时性不是很高，可以采用暂存的方式




如果是有大促或者抢购导致消息突增，短时间内不可能通过优化代码来解决，唯一的方法是通过增加消费者实例数来提升总体的消费能力。如果短时间内没有足够的服务器资源进行扩容，那么可以将系统降级，关闭一些不重要的业务，减少生产者生产的消息数量，让系统尽可能正常运转，服务一些重要的业务。
如果通过监控发现生产消息的速度和消费消息的速度都没有什么异常，那就需要检查一下消费端，是不是消费失败导致了一条消息反复消费。


如果监控到消费变慢了，需要检查一下消费实例，分析一下是什么原因导致消费变慢。可以检查一下日志看是否有大量的消费错误，还可以通过打印堆栈信息，看一下消费线程是不是卡在什么地方了，比如发生死锁或者等待资源。


如果业务允许延迟处理，也可以采用将消息暂存，峰值过后回放的策略。防止队列溢出
```



### 如何实现事务消息

```
可以在开放问题里问


第一阶段：生产者向MQ服务器发送事务消息(prepare消息)，服务端确认后回调通知生产者执行本地事务(此时消息为Prepare消息，存储于RMQ_SYS_TRANS_HALF_TOPIC队列中，不会被消费者消费)


第二阶段：生产者执行完本地事务后(业务执行完成，同时将消息唯一标记，如transactionId与该业务执行记录同时入库，方便事务回查)，根据本地事务执行结果，返回Commit/Rollback/Unknow状态码


1、服务端若收到Commit状态码，则将prepare消息变为提交(正常消息，可被消费者消费)
2、收到Rollback则对消息进行回滚(丢弃消息)
3、如果状态回执失败，Kafka 和 RocketMQ 方案不同：


1、Kafka 的解决方案：
直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。


2、RocketMQ 的解决方案：
在 RocketMQ 中的事务实现中，增加了事务反查的机制来解决事务消息提交失败的问题。如果 Producer 也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，我们的业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败

```



### mq的应用场景

```
异步处理
场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式


应用解耦
1、传统模式：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。
缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合
2、mq方案订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功
库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作
假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦


流量削锋
流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。
应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。


日志处理
日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。也属于异步处理。


消息通讯
消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。

```

