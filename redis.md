# redis

### 分布式锁-谁加锁谁释放如何保证

```
要满足以下几个条件：
参考 reddsion


考点，如何标识线程唯一性，uuid + tid
数据结构 hash ，有人候选人会说 string
```



### key超时时间10s，业务执行20s，这种场景如何处理

```
分布式锁过期了，解决方案当然就是续期啦。那么应该怎么续期呢？
思路一：任务执行的时候，开辟一个守护线程，在守护线程中每隔一段时间重新设置过期时间。
思路二：通过Redisson来实现，redisson锁获取成功后，注册一个定时任务，每隔一定时间(this.internalLockLeaseTime / 3L)就去续约。internalLockLeaseTime可配置，默认30s。
```



### 如何实现可重入锁

```
类似redisson
redis key：FairLock 过期时间 默认30s,可配置（lockWatchdogTimeout）
hash key：uuid+”:”+threadId
hash value: 1 (可重入++)
```



### 如何实现公平锁

```
类似redisson
hash:
redis key：FairLock 过期时间 默认30s,可配置（lockWatchdogTimeout）
hash key：uuid+”:”+threadId
hash value: 1 (可重入++)


list:
redis key：redisson_lock_queue:{FairLock}
list value：uuid+”:”+threadId


zset:
redis key：redisson_lock_timeout:{FairLock}      
zset value：uuid+”:”+threadId
zset 分数：1、如果当前排队处于第一位获取当前锁的过期时间+当前时间+5s（线程等待时间，固定5s）2、如果不是获取当前队首value，取得zset中的score+5s，即队首过期时间+当前时间+5s


如何服务挂了 ，通知不到其他节点如何处理


往zk引，让候选人聊一下zk实现公平锁的方式 


todo 
```



### 大量keys过期产生的雪崩现象

```
（1）在缓存的时候给时间加上一个随机值，设置不同的缓存过期时间，减少缓存在同一时间过期的概率。
（2）热点key设置缓存永不过期，数据有更新再主动更新。 结合淘汰策略 聊负面作用
```



### 缓存穿透

```


缓存失效，短时间大量读请求指向数据库，数据库压力过大，造成缓存击穿


解决方案：
考察点 


todo 补充方案
```



### 如何保证redis 与db 数据一致性

```
todo
补充答案


1、读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
2、更新的时候，先更新数据库，然后再删除缓存。
为什么是删除缓存，而不是更新缓存：因为有些场景更新很频繁，但是可能读取次数很少，直接更新浪费性能

```



### zset实现滑动窗口限流

```
可以通过 zset   score 来圈出这个时间窗口来。而且只需要保留这个时间窗口，窗口之外的数据都可以砍掉。 zset 的 value 需要保证唯一性即可，用 uuid 会比较浪费空间，使用毫秒时间戳。
用一个 zset 结构记录用户的行为历史，每一个行为都会作为 zset 中的一个key 保存下来。同一个用户同一种行为用一个 zset 记录。为节省内存，只需要保留时间窗口内的行为记录，同时如果用户是冷用户，滑动时间窗口内的行为是空记录，这个 zset 就可以从内存中移除，不再占用空间。
代码整体思路就是：每一个行为到来时，都维护一次时间窗口。将时间窗口外的记录全部清理掉，只保留窗口内的记录。
zset 集合中只有 score 值非常重要， value 值没有特别的意义，只需要保证它是唯一的就可以了。
因为这几个连续的 Redis 操作都是针对同一个 key 的，使用 pipeline 可以显著提升Redis 存取效率。但这种方案也有缺点，因为它要记录时间窗口内所有的行为记录，如果这个量很大，比如限定 60s 内操作不得超过 100w 次这样的参数，它是不适合做这样的限流的，因为会消耗大量的存储空间

```



### set nx ex区别

```
setex：
setex key seconds value：将key值设置为value，并将设置key的生存周期
1，属于原子操作，作用和set key value、expire key seconds作用一致。
2，如果key值存在，使用setex将覆盖原有值
setnx:
setnx key value:只有当key不存在的情况下，将key设置为value；若key存在，不做任何操作，结果成功返回1，失败返回0
```



### string 底层数据结构

```
考察点：


SDS 偏概念




redis原理之string底层数据结构SDS
struct sdshdr{
     //记录buf数组中已使用字节的数量
     //等于 SDS 保存字符串的长度
     int len;
     //记录 buf 数组中未使用字节的数量
     int free;
     //字节数组，用于保存字符串
     char buf[];
}
用SDS保存字符串 “Redis”具体图示如下：
 len 为字符串的实际长度  在redis中获取字符串的key长度的时间复杂度为O(1)
 free 为 buf数组中剩余的空间大小（相对于 C 语言对于字符串的定义，多出了 len 属性以及 free 属性）
 buf 保存字符串的数组
使用free杜绝了缓冲区溢出如果free的长度不够值的长度则自动会开辟len长度的空间
```



### 常用的数据结构有哪些，以及使用场景

```
常用结构：


根据候选人场景 


eg：候选人使用string ，为什么使用string做缓存，是否有其他更合适的结构




String 简单数值，分布式锁，计数等；List 队列，栈等；Hash 对象存储；Set 各种无重复集合，例如一个公司下所有用户具有的标签id集合；SortedSet：各种排行榜，例如评分排行榜

```



### zset 底层数据结构

```
使用场景：
字典树
跳表
```



### 缓存持久化方式

```
优劣 
部署方式 ，一般是混合模式


aof:保存命令,rdb保存所有数据。
```



### 多个key遍历场景的最优方案，如何合理遍历容器

```
hscan，使用cursor持续迭代到归0为止
KEYS命令一次性返回所有匹配的key，所以，当redis中的key非常多时，对于内存的消耗和redis服务器都是一个隐患
SCAN 每次执行都只会返回少量元素，所以可以用于生产环境，而不会出现像 KEYS 或者 SMEMBERS 命令带来的可能会阻塞服务器的问题。
```



### IO多路复用原理

```
todo
单独放到 IO 考察点


“多路”「指的是多个网络连接客户端，」“复用”指的是复用同一个线程(单进程)。I/O 多路复用其实是使用一个线程来检查多个 Socket 的就绪状态，在单个线程中通过记录跟踪每一个 socket（I/O流）的状态来管理处理多个 I/O 流。
Redis 的 I/O 多路复用模型进行一下描述说明：
(1)一个 socket 客户端与服务端连接时，会生成对应一个套接字描述符(套接字描述符是文件描述符的一种)，每一个 socket 网络连接其实都对应一个文件描述符。
(2)多个客户端与服务端连接时，Redis 使用 「I/O 多路复用程序」 将客户端 socket 对应的 FD 注册到监听列表(一个队列)中。当客服端执行 read、write 等操作命令时，I/O 多路复用程序会将命令封装成一个事件，并绑定到对应的 FD 上。 (3)「文件事件处理器」使用 I/O 多路复用模块同时监控多个文件描述符（fd）的读写情况，当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器进行处理相关命令操作。 (5)整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，当其中一个 client 端达到写或读的状态，文件事件处理器就马上执行，从而就不会出现 I/O 堵塞的问题，提高了网络通信的性能。 (6)Redis 的 I/O 多路复用模式使用的是 「Reactor 设置模式」的方式来实现。
```



### redis慢的场景

```


常见考察点：


不合理指令 
bigkey 内存的申请和释放
数据过期、数据淘汰 -》 淘汰机制




CPU 相关：使用复杂度过高命令、数据的持久化，都与耗费过多的 CPU 资源有关
内存相关：bigkey 内存的申请和释放、数据过期、数据淘汰、碎片整理、内存大页、内存写时复制都与内存息息相关
磁盘相关：数据持久化、AOF 刷盘策略，也会受到磁盘的影响
网络相关：短连接、实例流量过载、网络流量过载，也会降低 Redis 性能
计算机系统：CPU 结构、内存分配，都属于最基础的计算机系统知识
操作系统：写时复制、内存大页、Swap、CPU 绑定，都属于操作系统层面的知识
```



